#![allow(unused_unsafe)]
#![allow(unconditional_panic)]
#![allow(arithmetic_overflow)]
#![no_main]

{% if use_reveal_u32 %}
use openvm::io::{read, reveal_u32};
{% else %}
use openvm::io::{read, reveal};
{% endif %}
use core::arch::asm;

openvm::entry!(main);

#[no_mangle]
pub fn main() {
    // 1. Inject initial register states from Host (excluding x0)
    {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
    let mut x{{ reg_idx }}: u32 = read();
    {% endfor %}

    // Variable to capture final x0 value (to check if it's still 0)
    let mut final_x0: u32 = 0;

    // 2. Execute random instruction sequence
    unsafe {
        asm!(
            // Fuzzing instruction sequence
            {% for inst in instructions %}
            "{{ inst }}",
            {% endfor %}

            // Manually capture x0 into a temporary register that's mapped to final_x0
            "mv {final_x0}, x0",

            // Bind to physical registers (excluding x0 from operands)
            {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
            inout("x{{ reg_idx }}") x{{ reg_idx }},
            {% endfor %}
            
            final_x0 = out(reg) final_x0,
            
            options(nostack)
        );
    }

    // 3. Reveal final results back to Host using stream 0
    // Always include x0 (idx=0) so the host can validate it stayed zero.
    {% if use_reveal_u32 %}
    reveal_u32(0, 0);
    reveal_u32(final_x0, 0);
    {% else %}
    reveal(0, 0);
    reveal(final_x0, 0);
    {% endif %}

    {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
    {% if use_reveal_u32 %}
    reveal_u32({{ reg_idx }}, 0);
    reveal_u32(x{{ reg_idx }}, 0);
    {% else %}
    reveal({{ reg_idx }}, 0);
    reveal(x{{ reg_idx }}, 0);
    {% endif %}
    {% endfor %}
}
