#![cfg_attr(target_arch = "riscv32", no_std, no_main)]
#![allow(unconditional_panic)]
#![allow(arithmetic_overflow)]

use core::arch::asm;

#[nexus_rt::public_input(initial_regs)]
#[nexus_rt::main]
fn main(initial_regs: [u32; {{ initial_regs.keys()|length - 1 }}]) -> [u32; {{ output_word_count }}] {
    {% set idx = namespace(i=0) %}
    {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
    let mut x{{ reg_idx }}: u32 = initial_regs[{{ idx.i }}];
    {% set idx.i = idx.i + 1 %}
    {% endfor %}

    let mut final_x0: u32 = 0;

    unsafe {
        asm!(
            {% for inst in instructions %}
            "{{ inst }}",
            {% endfor %}
            "mv {final_x0}, x0",

            {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
            inout("x{{ reg_idx }}") x{{ reg_idx }},
            {% endfor %}
            final_x0 = out(reg) final_x0,
            options(nostack)
        );
    }

    let mut out: [u32; {{ output_word_count }}] = [0u32; {{ output_word_count }}];
    let mut i: usize = 0;
    {% for reg_idx in initial_regs.keys() %}
    out[i] = {{ reg_idx }}u32;
    {% if reg_idx == 0 %}
    out[i + 1] = final_x0;
    {% else %}
    out[i + 1] = x{{ reg_idx }};
    {% endif %}
    i += 2;
    {% endfor %}
    out
}
