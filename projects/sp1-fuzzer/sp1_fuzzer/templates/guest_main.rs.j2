#![allow(unused_unsafe)]
#![allow(unconditional_panic)]
#![allow(arithmetic_overflow)]
#![no_main]

use core::arch::asm;

sp1_zkvm::entrypoint!(main);

pub fn main() {
    // 1. Inject initial register states from Host (excluding x0)
    {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
    let mut x{{ reg_idx }}: u32 = sp1_zkvm::io::read();
    {% endfor %}

    // Variable to capture final x0 value (to check if it's still 0)
    let mut final_x0: u32 = 0;

    // 2. Execute random instruction sequence
    unsafe {
        asm!(
            {% for inst in instructions %}
            "{{ inst }}",
            {% endfor %}

            "mv {final_x0}, x0",

            {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
            inout("x{{ reg_idx }}") x{{ reg_idx }},
            {% endfor %}
            final_x0 = out(reg) final_x0,
            options(nostack)
        );
    }

    // 3. Commit register outputs as (reg_idx, value) pairs for host parsing
    {% for reg_idx in initial_regs.keys() %}
    sp1_zkvm::io::commit(&{{ reg_idx }}u32);
    {% if reg_idx == 0 %}
    sp1_zkvm::io::commit(&final_x0);
    {% else %}
    sp1_zkvm::io::commit(&x{{ reg_idx }});
    {% endif %}
    {% endfor %}
}
