#![allow(unused_unsafe)]
#![allow(unconditional_panic)]
#![allow(arithmetic_overflow)]
#![no_main]

use core::arch::asm;
use pico_sdk::io::{commit_bytes, read_as};

pico_sdk::entrypoint!(main);

pub fn main() {
    // 1) Inject initial register states from Prover (excluding x0)
    {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
    let mut x{{ reg_idx }}: u32 = read_as();
    {% endfor %}

    // Variable to capture final x0 value (to check if it's still 0)
    let mut final_x0: u32 = 0;

    // 2) Execute random instruction sequence
    unsafe {
        asm!(
            {% for inst in instructions %}
            "{{ inst }}",
            {% endfor %}

            "mv {final_x0}, x0",

            {% for reg_idx in initial_regs.keys() if reg_idx != 0 %}
            inout("x{{ reg_idx }}") x{{ reg_idx }},
            {% endfor %}
            final_x0 = out(reg) final_x0,
            options(nostack)
        );
    }

    // 3) Commit register outputs as (reg_idx, value) pairs for host parsing
    {% for reg_idx in initial_regs.keys() %}
    commit_bytes(&({{ reg_idx }}u32.to_le_bytes()));
    {% if reg_idx == 0 %}
    commit_bytes(&(final_x0.to_le_bytes()));
    {% else %}
    commit_bytes(&(x{{ reg_idx }}.to_le_bytes()));
    {% endif %}
    {% endfor %}
}
